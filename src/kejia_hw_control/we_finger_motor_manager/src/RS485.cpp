#include "RS485.h"

static byte auchCRCHi[] =
{0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,

   0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,

   0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,

   0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,

   0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,

   0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,

   0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,

   0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,

   0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,

   0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,

   0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,

   0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,

   0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,

   0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,

   0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,

   0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,

   0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,

   0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,

   0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,

   0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,

   0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,

   0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,

   0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,

   0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,

   0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,

   0x80,0x41,0x00,0xC1,0x81,0x40

};
static char auchCRCLo[] = {

0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,

0x07,0xC7,0x05,0xC5,0xC4,0x04,0xCC,0x0C,0x0D,0xCD,

0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,

0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,

0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,0x14,0xD4,

0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,

0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,

0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,

0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,

0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,

0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,

0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,

0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,

0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,

0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,

0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,

0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,

0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,

0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,

0x70,0xB0,0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,

0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,

0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,

0x99,0x59,0x58,0x98,0x88,0x48,0x49,0x89,0x4B,0x8B,

0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,

0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,

0x43,0x83,0x41,0x81,0x80,0x40

};

RS485::RS485(const char * _name, byte id, CSerialCom* com)
{
  this->com = com;
  pressure = 0.0;
  this->id = id;
  last_id = id;
  
}
void RS485::init()
{
  bool onedevice =true;
  if(onedevice)
  {
    getId();  //passing, at the first time there will be a error of reading.
    usleep(200000);
    //ROS_WARN("initing valve sensor....");

    last_id=getId();
    //printf("setted before id is %d\n",last_id);
    usleep(200000);
    //printf("new import id is %d\n",id);
    setId(id);
    usleep(200000);
    byte returnId=getId();

    usleep(2000000);
    returnId=getId();

    if(returnId!=id) ROS_WARN("the valvesensor id is not set successfully");
    //id = returnId;
    ROS_ERROR("Notice! the id of valve sensor is set to %d",id);
    usleep(200000);
  }
  else
  {
    return;
  } 

}

byte RS485::getId()
{
  byte data[8];
  data[0]= 0xFF;
  data[1]= 0x03;
  data[2]= 0x00;
  data[3]= 0x0F;
  data[4]= 0x00;
  data[5]= 0x01;
  data[6]= 0xA1;
  data[7]= 0xD7;
  com->PushData(data,8);
  //ROS_WARN("get id");
  //debugprint(data);
  byte data_received[8];
  com->ReceiveData(data_received, 7);
  // ROS_WARN("returned id");
  //debugprint(data_received);

  return data_received[4];
}

void RS485::debugprint(byte* data)
{
  for(int i =0;i<8;i++)
    {
      printf("%02X ",data[i]); 
    }
  printf("\n");
}

bool RS485::setId(byte newid)
{
  byte data[8];
  data[0]= last_id;
  data[1]= 0x06;
  data[2]= 0x00;
  data[3]= 0x0F;
  data[4]= 0x00;
  data[5]= newid;
  data[6]= '\0';
  data[7]= '\0';

  CRC166(data, 6);
  data[6]=CRC[0];
  data[7]=CRC[1];

  
  //debugprint(data);
  com->PushData(data,8);

  usleep(2000000);

  byte data_received[8];
  com->ReceiveData(data_received, 8);
  //debugprint(data_received);
  usleep(1000000);
  com->ReceiveData(data_received, 8);

  if(data_received[4]==newid)
    { last_id = newid; id= newid;return true;}
  else
    {
      ROS_ERROR("valve sensor id setting is failed, please reboot the robot and correct it!!");
      return false;
    }

}

void RS485::getPressure()
{
  byte data[8];
  data[0]= id;
  data[1]= 0x03;
  data[2]= 0x00;
  data[3]= 0x00;
  data[4]= 0x00;
  data[5]= 0x01;
  data[6]= '\0';
  data[7]= '\0';

  CRC166(data, 6);
  data[6]=CRC[0];
  data[7]=CRC[1];

  // debugprint(data);
  com->PushData(data,8);
  usleep(1*1000);
  byte data_received[8];
  com->ReceiveData(data_received, 7);
  // debugprint(data_received);

  byte pressuredata[2];
  pressuredata[0]=data_received[3];
  pressuredata[1]=data_received[4];

  int i = pressuredata[0]*256+pressuredata[1];
  pressure = (float)(i)/10.0;

}

void RS485::CRC166(byte *puchMsg,unsigned short usDataLen)

{
  byte uchCRCHi = 0xFF ;
  byte uchCRCLo = 0xFF ;
  unsigned uIndex ;

  while (usDataLen--)

    {

      uIndex = uchCRCHi ^ *puchMsg++ ;

      uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ;

      uchCRCLo = auchCRCLo[uIndex] ;

    }
  CRC[1] = uchCRCLo;
  CRC[0] = uchCRCHi;
  //return ((uchCRCHi << 8) | uchCRCLo);

}
